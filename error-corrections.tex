\documentclass{article}



\usepackage{arxiv}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}		% Can be removed after putting your text content
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{doi}

\usepackage{sectsty}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{braket}



\title{A Basic Overview of Quantum Computing Fundamentals and Error Correction}

%\date{September 9, 1985}	% Here you can change the date presented in the paper title
%\date{} 					% Or removing it

\author{Anthony Thonnard \\
	Department of Computer Science\\
	Cranberry-Lemon University\\
	Pittsburgh, PA 15213 \\
	\texttt{hippo@cs.cranberry-lemon.edu} \\
	%% examples of more authors
	\And
	Benjamin Dobbins \\
	Department of Electrical Engineering\\
	Mount-Sheikh University\\
	Santa Narimana, Levand \\
	\texttt{yo-mama@ee.mount-sheikh.edu} \\
	%% \AND
	%% Coauthor \\
	%% Affiliation \\
	%% Address \\
	%% \texttt{email} \\
	%% \And
	%% Coauthor \\
	%% Affiliation \\
	%% Address \\
	%% \texttt{email} \\
	%% \And
	%% Coauthor \\
	%% Affiliation \\
	%% Address \\
	%% \texttt{email} \\
}

% Uncomment to remove the date
%\date{}

% Uncomment to override  the `A preprint' in the header
%\renewcommand{\headeright}{Technical Report}
%\renewcommand{\undertitle}{Technical Report}
% \renewcommand{\shorttitle}{\textit{arXiv} Template}

%%% Add PDF metadata to help others organize their library
%%% Once the PDF is generated, you can check the metadata with
%%% $ pdfinfo template.pdf
\hypersetup{
pdftitle={A Basic Overview of Quantum Computing Fundamentals and Error Correction},
pdfsubject={q-bio.NC, q-bio.QM},
pdfauthor={Anthony Thonnard, Benjamin Dobbins},
pdfkeywords={First keyword, Second keyword, More},
}

\begin{document}
\maketitle
\begin{abstract}
	\lipsum[1]
\end{abstract}



\twocolumn[]
\section{Qubits}
\label{sec:qubits}
Qubits are the fundamental units of information in quantum computers, and are essentially the quantum analogue of classical bits. Classical bits are represented as a $0$ or 
a $1$, denoted by the presence of an electrical current. They store binary information in a classical computer, and can be combined and abstracted to store more complex 
information. Qubits are similarly limited to two possible physical states, also described as $0$ or $1$, but because of their quantum mechanical properties, they can also be 
in a superposition of those two states. Consequently, while bits must only be a $0$ or a $1$ at all times (i.e. the electrical current is present or it is not), qubits 
can be in an unknown state, in which it cannot be determined whether the qubit is a $0$ or a $1$ unless it is being observed. This is useful because we are able to manipulate 
the probabilities of the qubit being in either state, and thus we can perform operations on the qubit that are not possible with classical bits. Furthermore, 
quantum entanglement can be applied to link multiple qubits together, creating a mutual dependence between their probabilities of taking each state. As a result, the computer's
ability to make complex calculations in shorter amounts of time is exponentially increased.

\subsection{Qubits and Probabilities}
\label{sec:qubitprobs}


\subsubsection{The Mathematical Representation of Qubits}
\label{sec:mathrep}
Qubits are represented mathematically as vectors, more specifically as unit normal column vectors in a two-dimensional complex vector space. The two basis vectors of this 
vector space are denoted as $\ket{0}$ and $\ket{1}$, and are represented as follows: 

\begin{center}
	$\ket{0} = \begin{bmatrix} 1 \\ 0 \end{bmatrix}$ \hspace{1cm} $\ket{1} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}$	
\end{center}

The unit normal nature of these vectors means that they always have a magnitude of $1$ (the square root of the sum of the squared components is 1). This magnitude 
can be thought of as the probability that the qubit will take any state when observed (always must be 1 since a state must be observed). While that information alone may seem 
useless, it entails that the square of each component of the vector is equal to the probability of the system being in that state. The first row of the vector represents the 
$\ket{0}$ component, and the second row represents the $\ket{1}$ component. For the basis vector $\ket{0}$, the probability of being in the $\ket{0}$ state is $1^{2}$, and the 
probability of being in the $\ket{1}$ state is $0^{2}$. Similarly, for the basis vector $\ket{1}$, the probability of being in the $\ket{0}$ state is $0^{2}$, and the probability of 
being in the $\ket{1}$ state is $1^{2}$. Consider the qubit below:

\begin{center}
	$
	q =
	\begin{bmatrix}
		\frac{1}{2} \\
		\frac{\sqrt{3}}{2}
	\end{bmatrix}
	$
\end{center}

In this case, the probability of $q$ being in the $\ket{0}$ state would be $ (\frac{1}{2})^{2} = \frac{1}{4}$, while the probability of $q$ being in the $\ket{1}$ state would be 
$ (\frac{\sqrt{3}}{2})^{2} = \frac{3}{4}$.
\textbf{ADD REFERENCE AND EXPLANATION FOR COMPLEX VECTOR SPACE}. 


\subsection{Quantum Coin Toss}
\label{sec:quantumcointoss}
\subsection{Multi-Qubit Systems}
\label{sec:multiqubitsystems}

A one-qubit system is about as useful as a single bit in a classical computer, so it is necessary to combine multiple qubits together to create a more complex system. This can
be accomplished by taking the tensor product of two qubits/systems of qubits. The tensor product of two vectors is a vector that represents the combined system of the two
vectors. For example, the tensor product of the two qubits $\ket{0}$ and $\ket{1}$ would be:

\begin{center}
	$
	\ket{0} \otimes \ket{1} =
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
	\otimes
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		1 \cdot
		\begin{bmatrix}
			0 \\
			1 \\
		\end{bmatrix} \\
		0 \cdot 
		\begin{bmatrix}
			0 \\
			1 \\
		\end{bmatrix} \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0 \\
	\end{bmatrix}
	=
	\ket{01}
	$
\end{center}

Notice that the tensor product of two vectors of length $n$ and $m$ will result in a vector of length $n \cdot m$. The four-dimensional vector above represents the two qubit 
system where the first qubit is in the $0$ state and the second qubit is in the $1$ state (hence the $\ket{01}$ notation). \textbf{ADD REFERENCE FOR TENSOR/KROENECKER PRODUCT}. 
We can also take the tensor product of larger qubit systems, take the following example:

\begin{center}
	$
	\ket{01} \otimes \ket{10} =
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0 \\
	\end{bmatrix}
	\otimes
	\begin{bmatrix}
		0 \\
		0 \\
		1 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \cdot
		\begin{bmatrix}
			0 \\
			0 \\
			1 \\
			0 \\
		\end{bmatrix} \\
		1 \cdot
		\begin{bmatrix}
			0 \\
			0 \\
			1 \\
			0 \\
		\end{bmatrix} \\
		0 \cdot
		\begin{bmatrix}
			0 \\
			0 \\
			1 \\
			0 \\
		\end{bmatrix} \\
		0 \cdot
		\begin{bmatrix}
			0 \\
			0 \\
			1 \\
			0 \\
		\end{bmatrix} \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		1 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
	\end{bmatrix}
	=	
	\ket{0110}
	$
\end{center}


\subsubsection{Example of a Multi-Qubit System}
\label{sec:examplemultisystem}
\subsection{The Bloch Sphere}
\label{sec:blochsphere}
\subsubsection{Bloch Sphere Representations}
\label{sec:blochspherereps}
\subsection{Physical Qubits}
\label{sec:physicalqubits}

A physical qubit is a physical system that can be used to represent a qubit. There are many different types of physical qubits, but the most common are the spin of an electron,
the polarization of a photon, and the energy levels of an atom. The commonalities shared by these systems are that they all have two possible observed states, yet they can all
be in a superposition of those states. For the spin of an electron, the $\ket{0}$ state would be spin up, and the $\ket{1}$ state would be spin down. These physical qubits based 
on spin can be modeled by the Bloch sphere, which is a unit sphere that represents the possible states of a qubit. The north pole of the sphere represents the $\ket{0}$ state,
and the south pole represents the $\ket{1}$ state. Any point outside of the poles represents the qubit in a state of superposition, and the point on the sphere represents the
\textbf{fill this in later, think it's the probabilities, but not sure}. The polarization of a photon, or the direction of its electromagnetic field, can be used with 
horizontally polarized representing the $\ket{0}$ state, and vertically polarized representing the $\ket{1}$ state. The energy levels of an atom are used in trapped ion 
quantum computers, and the $\ket{0}$ state is represented by the ground state of the atom, while the $\ket{1}$ state is represented by the excited state of the atom.

\vspace{5mm}

Physical qubits are used to store all of the information in a quantum computer, meaning ideally they would be resistant to errors, to prevent loss of information. However, in 
reality, physical qubits are extremely susceptible to errors, and thus error correction is necessary to ensure the accuracy of the information stored in qubits. The most 
common types of errors are bit-flip and phase-flip errors, which will be discussed in more depth in section \textbf{Add reference to section} \ref{sec:errors}. Since physical
qubit systems are so unfathomably delicate, these errors are prone to occur quite often and are caused by a multitude of different factors. This is a major reason why error 
correction is so important; there is an abundance of noise and errors when working with these systems, which leads to information loss. The most common causes of
errors are \textbf{find common causes. One can be qubits interacting with each other, causing interference in their wave functions}. Because one of the main contributors to 
noise is qubits interfering with each other, the probability of information loss increases exponentially as the number of qubits in a system increases. Since it is inherently 
impossible to eliminate the noise in quantum computers, it is necessary to devise a system that allows correction of these errors, which is the purpose of logical qubits.



\subsubsection{Trapped Ion Qubits}
\label{sec:trappedionqubits}



\subsection{Logical Qubits and Limitations of Quantum Computers}
\label{sec:logicalqubitsbrief}
Logical qubits will be discussed in further detail in section \ref{sec:baconshor}, but for now it is important to understand that logical qubits are a method of representing
ideal, error-resistant qubits. Logical qubits are built using a system of multiple physical qubits that are entangled together in such a way that some of the qubits, called 
auxiliary qubits, can detect and/or correct errors in the other qubits, called data qubits. As is shown in section \ref{sec:baconshor}, simpler logical qubits that only 
detect/correct certain types of errors can be built using smaller amount of qubits, but more practical logical qubits require at least \textbf{number} physical qubits to detect
multiple different types of errors. The number of physical qubits required to build a logical qubit is called the overhead of the logical qubit, and is a major factor in the
practicality of a logical qubit. \textbf{Say something about how there really aren't any "practical" logical qubits yet, since they all have such high overheads, computers 
cannot contain very many qubits yet, and there are issues with gate operations on logical qubits}.













\section{Quantum Circuits}
\label{sec:quantumcircuits}



\subsection{Basic Quantum Gates}
\label{sec:basicgates}
Now that we have introduced qubits and the idea that they can be in different states, we can discuss how those states are manipulated. In classical computers, we use logic
gates to manipulate the states of bits. Similarly, qubits and qubit systems are altered using quantum gates. Quantum gates are represented as matrices, and are applied to
qubits by multiplying the gate matrix by the qubit vector. The result of this multiplication is the new state of the qubit.

\subsubsection{X Gate}
\label{sec:xgate}

The X gate is the quantum analogue of the NOT gate in classical computers. It is represented by the following matrix:

\begin{center}
	$
	\begin{bmatrix}
		0 & 1 \\
		1 & 0
	\end{bmatrix}
	$
\end{center}

Similar to classical computers, if the X gate is applied to a qubit in the $\ket{0}$ state, that qubit will then be in the $\ket{1}$ state and vice versa. This can be clearly
shown using the mathematical representation of the qubit and the gate:

\[
	\begin{bmatrix}
		0 & 1 \\
		1 & 0
	\end{bmatrix}
	\times
	\begin{bmatrix}
		1 \\
		0
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1
	\end{bmatrix}
\]
\[
	\begin{bmatrix}
		0 & 1 \\
		1 & 0
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1
	\end{bmatrix}
	=
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
\]

\textbf{Add something about how the X gate flips the qubit along the x-axis of the Bloch sphere (or whatever axis it was, I forget)}

\subsubsection{Y Gate}
\label{sec:ygate}

The Y gate is represented by the following matrix:

\[
	\begin{bmatrix}
		0 & -i \\
		i & 0
	\end{bmatrix}
\]

\textbf{Fill in information about what the Y gate does}. Applying it to the $\ket{0}$ state and the $\ket{1}$ state, we get:

\[
	\begin{bmatrix}
		0 & -i \\
		i & 0
	\end{bmatrix}
	\times
	\begin{bmatrix}
		1 \\
		0
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		i
	\end{bmatrix}
\]
\[
	\begin{bmatrix}
		0 & -i \\
		i & 0
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		-i \\
		0 \\
	\end{bmatrix}
\]

\subsubsection{Z Gate}
\label{sec:zgate}

The Z gate is represented by the following matrix:

\[
	\begin{bmatrix}
		1 & 0 \\
		0 & -1
	\end{bmatrix}
\]

\textbf{Fill in information about what the Z gate does}. Applying it to the $\ket{0}$ state and the $\ket{1}$ state, we get:

\[
	\begin{bmatrix}
		1 & 0 \\
		0 & -1
	\end{bmatrix}
	\times
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
\]
\[
	\begin{bmatrix}
		1 & 0 \\
		0 & -1
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		-1 \\
	\end{bmatrix}
\]

\subsubsection{Hadamard Gate}
\label{sec:hadamardgate}

The Hadamard gate is represented by the following matrix:

\[
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
	\end{bmatrix}
\]

The hadamard gate is used to put a qubit into a superposition of the $\ket{0}$ and $\ket{1}$ states. This is extremely useful because it is what allows us to capitalize on the
quantum mechanical properties of qubits. Applying the hadamard gate to the $\ket{0}$ state and the $\ket{1}$ state, we get:

\[
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} \\
	\end{bmatrix}
\]
\[
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} \\
		-\frac{1}{\sqrt{2}} \\
	\end{bmatrix}
\]

Notice that in each of those cases the magnitude of the resulting vector is still $1$, yet the probabilities of the qubit being in the $\ket{0}$ and $\ket{1}$ states are now
both $ \frac{1}{2}$. The hadamard gate can also be applied again to remove these superpositions and return the qubits to their original states:

\[
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
\]
\[
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} \\
		-\frac{1}{\sqrt{2}} \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
\]

\subsubsection{CNOT/CX Gate}
\label{sec:cnotgate}

The CNOT gate is another one of the most important gates in quantum computing, since facilitates the entanglement of qubits, which is a key component of quantum computing. It does
this by essentially projecting the state of one qubit onto another qubit (\textbf{double check this}). The CNOT gate is the first gate we have discussed that acts on multiple
qubits instead of just one. Therefore, we must recall the tensor product of qubits that we discussed in section \ref{sec:mathrep}. We can use the tensor product to represent 
two qubits in a system, and then apply the CNOT gate to that system. Consider the following two-qubit systems:

\[
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	\otimes
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		0 \\
		1 \\
		0 \\
	\end{bmatrix}
	=
	\ket{10}
\]
\[
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
	\otimes
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0 \\
	\end{bmatrix}
	=
	\ket{01}
\]

If we apply the CNOT gate to the $\ket{10}$ system, we get:

\[
	\begin{bmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 0 & 1 \\
		0 & 0 & 1 & 0 \\
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		0 \\
		1 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		0 \\
		0 \\
		1 \\
	\end{bmatrix}
\]

We end up with the $\ket{11}$ state, meaning both qubits in the system are now in the $\ket{1}$ state. This is because, as previously described, the CNOT gate projects the state
of the first qubit onto the second qubit. Since the first qubit was in the $\ket{1}$ state, the second qubit is now also in the $\ket{1}$ state. Knowing this, we can now make 
the prediction that applying the CNOT gate to the $\ket{01}$ system will result in the $\ket{00}$ system, since the first qubit is in the $\ket{0}$ state. However, this is not
the case:

\[
	\begin{bmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 0 & 1 \\
		0 & 0 & 1 & 0 \\
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0 \\
	\end{bmatrix}
\]

\textbf{explain why this is, maybe give another example with a two qubit system in superposition}

\subsubsection{CZ Gate}
\label{sec:czgate}

The CZ gate is represented by the following matrix:

\[
	\begin{bmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 1 & 0 \\
		0 & 0 & 0 & -1 \\
	\end{bmatrix}
\]

\textbf{explain what the cz gate does}



\subsection{Basic Rotation Circuit}
\label{sec:basicrotationcircuit}
\subsection{Combining Quantum Gates}
\label{sec:combininggates}
\subsection{Building Quantum Gates}
\label{sec:buildinggates}
\subsection{Grover's Algorithm}
\label{sec:groversalgorithm}
\subsubsection{Why Grover's Algorithm Works}
\label{sec:whygroverworks}
\subsection{Circuit Calculator}
\label{sec:circuitcalculator}







\section{Logical Qubits and Error Correction}
\label{sec:errorcorrection}

\subsection{Logical Qubits}
\label{sec:logicalqubits}
\subsection{Where Logical Qubits are Used}
\label{sec:wherelqused}
\subsection{Simple Error Correction Circuits}
\label{sec:simpleeccircuits}
\subsubsection{Bit-Flip Code}
\label{sec:bitflipcode}
\subsubsection{Phase-Flip Code}
\label{sec:phaseflipcode}
\subsection{Shor's Code}
\label{sec:shorscode}
\subsection{Logical Gates}
\label{sec:logicalgates}
\subsection{Bacon-Shor Code}
\label{sec:baconshor}
\subsubsection{Ancilla Qubits}
\label{sec:ancillaqubits}
\subsubsection{Why Ancilla Qubits Do Not Disrupt the System}
\label{sec:ancilladisruption}



\end{document}


\bibliographystyle{unsrtnat}
\bibliography{references}  %%% Uncomment this line and comment out the ``thebibliography'' section below to use the external .bib file (using bibtex) .


%%% Uncomment this section and comment out the \bibliography{references} line above to use inline references.
% \begin{thebibliography}{1}

% 	\bibitem{kour2014real}
% 	George Kour and Raid Saabne.
% 	\newblock Real-time segmentation of on-line handwritten arabic script.
% 	\newblock In {\em Frontiers in Handwriting Recognition (ICFHR), 2014 14th
% 			International Conference on}, pages 417--422. IEEE, 2014.

% 	\bibitem{kour2014fast}
% 	George Kour and Raid Saabne.
% 	\newblock Fast classification of handwritten on-line arabic characters.
% 	\newblock In {\em Soft Computing and Pattern Recognition (SoCPaR), 2014 6th
% 			International Conference of}, pages 312--318. IEEE, 2014.

% 	\bibitem{hadash2018estimate}
% 	Guy Hadash, Einat Kermany, Boaz Carmeli, Ofer Lavi, George Kour, and Alon
% 	Jacovi.
% 	\newblock Estimate and replace: A novel approach to integrating deep neural
% 	networks with existing applications.
% 	\newblock {\em arXiv preprint arXiv:1804.09028}, 2018.

% \end{thebibliography}
