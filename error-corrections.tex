\documentclass{article}



\usepackage{arxiv}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}		% Can be removed after putting your text content
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{doi}

\usepackage{kbordermatrix}
\usepackage{mathtools}
\usepackage{sectsty}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{braket}
\usepackage{calc}



\title{A Basic Overview of Quantum Computing Fundamentals and Error Correction}

%\date{September 9, 1985}	% Here you can change the date presented in the paper title
%\date{} 					% Or removing it

\author{Anthony Thonnard \\
	Department of Computer Science\\
	Cranberry-Lemon University\\
	Pittsburgh, PA 15213 \\
	\texttt{hippo@cs.cranberry-lemon.edu} \\
	%% examples of more authors
	\And
	Benjamin Dobbins \\
	Department of Electrical Engineering\\
	Mount-Sheikh University\\
	Santa Narimana, Levand \\
	\texttt{yo-mama@ee.mount-sheikh.edu} \\
	%% \AND
	%% Coauthor \\
	%% Affiliation \\
	%% Address \\
	%% \texttt{email} \\
	%% \And
	%% Coauthor \\
	%% Affiliation \\
	%% Address \\
	%% \texttt{email} \\
	%% \And
	%% Coauthor \\
	%% Affiliation \\
	%% Address \\
	%% \texttt{email} \\
}

% Uncomment to remove the date
%\date{}

% Uncomment to override  the `A preprint' in the header
%\renewcommand{\headeright}{Technical Report}
%\renewcommand{\undertitle}{Technical Report}
% \renewcommand{\shorttitle}{\textit{arXiv} Template}

%%% Add PDF metadata to help others organize their library
%%% Once the PDF is generated, you can check the metadata with
%%% $ pdfinfo template.pdf
\hypersetup{
pdftitle={A Basic Overview of Quantum Computing Fundamentals and Error Correction},
pdfsubject={q-bio.NC, q-bio.QM},
pdfauthor={Anthony Thonnard, Benjamin Dobbins},
pdfkeywords={First keyword, Second keyword, More},
}

\begin{document}
\maketitle
\begin{abstract}
	\lipsum[1]
\end{abstract}



\twocolumn[]
\section{Qubits}
\label{sec:qubits}
Qubits are the fundamental units of information in quantum computers, and are essentially the quantum analogue of classical bits. Classical bits are represented as a $0$ or 
a $1$, denoted by the presence of an electrical current. They store binary information in a classical computer, and can be combined and abstracted to store more complex 
information. Qubits are similarly limited to two possible physical states, also described as $0$ or $1$, but because of their quantum mechanical properties, they can also be 
in a superposition of those two states. Consequently, while bits must only be a $0$ or a $1$ at all times (i.e. the electrical current is present or it is not), qubits 
can be in an unknown state, in which it cannot be determined whether the qubit is a $0$ or a $1$ unless it is being observed. This is useful because we are able to manipulate 
the probabilities of the qubit being in either state, and thus we can perform operations on the qubit that are not possible with classical bits. Furthermore, 
quantum entanglement can be applied to link multiple qubits together, creating a mutual dependence between their probabilities of taking each state. As a result, the computer's
ability to make complex calculations in shorter amounts of time is exponentially increased.

\subsection{Qubits and Probabilities}
\label{sec:qubitprobs}


\subsubsection{The Mathematical Representation of Qubits}
\label{sec:mathrep}
Qubits are represented mathematically as vectors, more specifically as unit normal column vectors in a two-dimensional complex vector space. The two basis vectors of this 
vector space are denoted as $\ket{0}$ and $\ket{1}$, and are represented as follows: 

\begin{center}
	$\ket{0} = \begin{bmatrix} 1 \\ 0 \end{bmatrix}$ \hspace{1cm} $\ket{1} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}$	
\end{center}

The unit normal nature of these vectors means that they always have a magnitude of $1$ (the square root of the sum of the squared components is 1). This magnitude 
can be thought of as the probability that the qubit will take any state when observed (always must be 1 since a state must be observed). While that information alone may seem 
useless, it entails that the square of each component of the vector is equal to the probability of the system being in that state. The first row of the vector represents the 
$\ket{0}$ component, and the second row represents the $\ket{1}$ component. For the basis vector $\ket{0}$, the probability of being in the $\ket{0}$ state is $1^{2}$, and the 
probability of being in the $\ket{1}$ state is $0^{2}$. Similarly, for the basis vector $\ket{1}$, the probability of being in the $\ket{0}$ state is $0^{2}$, and the probability of 
being in the $\ket{1}$ state is $1^{2}$. Consider the qubit below:

\begin{center}
	$
	q =
	\begin{bmatrix}
		\frac{1}{2} \\
		\frac{\sqrt{3}}{2}
	\end{bmatrix}
	$
\end{center}

In this case, the probability of $q$ being in the $\ket{0}$ state would be $ (\frac{1}{2})^{2} = \frac{1}{4}$, while the probability of $q$ being in the $\ket{1}$ state would be 
$ (\frac{\sqrt{3}}{2})^{2} = \frac{3}{4}$.
\textbf{ADD REFERENCE AND EXPLANATION FOR COMPLEX VECTOR SPACE}. 


\subsection{Quantum Coin Toss}
\label{sec:quantumcointoss}
\subsection{Multi-Qubit Systems}
\label{sec:multiqubitsystems}

A one-qubit system is about as useful as a single bit in a classical computer, so it is necessary to combine multiple qubits together to create a more complex system. This can
be accomplished by taking the tensor product of two qubits/systems of qubits. The tensor product of two vectors is a vector that represents the combined system of the two
vectors. For example, the tensor product of the two qubits $\ket{0}$ and $\ket{1}$ would be:

\begin{center}
	$
	\ket{0} \otimes \ket{1} =
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
	\otimes
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		1 \cdot
		\begin{bmatrix}
			0 \\
			1 \\
		\end{bmatrix} \\
		0 \cdot 
		\begin{bmatrix}
			0 \\
			1 \\
		\end{bmatrix} \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0 \\
	\end{bmatrix}
	=
	\ket{01}
	$
\end{center}

Notice that the tensor product of two vectors of length $n$ and $m$ will result in a vector of length $n \cdot m$. The four-dimensional vector above represents the two qubit 
system where the first qubit is in the $0$ state and the second qubit is in the $1$ state (hence the $\ket{01}$ notation). \textbf{ADD REFERENCE FOR TENSOR/KROENECKER PRODUCT}. 
We can also take the tensor product of larger qubit systems, take the following example:

\begin{center}
	$
	\ket{01} \otimes \ket{10} =
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0 \\
	\end{bmatrix}
	\otimes
	\begin{bmatrix}
		0 \\
		0 \\
		1 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \cdot
		\begin{bmatrix}
			0 \\
			0 \\
			1 \\
			0 \\
		\end{bmatrix} \\
		1 \cdot
		\begin{bmatrix}
			0 \\
			0 \\
			1 \\
			0 \\
		\end{bmatrix} \\
		0 \cdot
		\begin{bmatrix}
			0 \\
			0 \\
			1 \\
			0 \\
		\end{bmatrix} \\
		0 \cdot
		\begin{bmatrix}
			0 \\
			0 \\
			1 \\
			0 \\
		\end{bmatrix} \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		1 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
		0 \\
	\end{bmatrix}
	=	
	\ket{0110}
	$
\end{center}


\subsubsection{Example of a Multi-Qubit System}
\label{sec:examplemultisystem}
\subsection{The Bloch Sphere}
\label{sec:blochsphere}
\subsubsection{Bloch Sphere Representations}
\label{sec:blochspherereps}
\subsection{Physical Qubits}
\label{sec:physicalqubits}

A physical qubit is a physical system that can be used to represent a qubit. There are many different types of physical qubits, but the most common are the spin of an electron,
the polarization of a photon, and the energy levels of an atom. The commonalities shared by these systems are that they all have two possible observed states, yet they can all
be in a superposition of those states. For the spin of an electron, the $\ket{0}$ state would be spin up, and the $\ket{1}$ state would be spin down. These physical qubits based 
on spin can be modeled by the Bloch sphere, which is a unit sphere that represents the possible states of a qubit. The north pole of the sphere represents the $\ket{0}$ state,
and the south pole represents the $\ket{1}$ state. Any point outside of the poles represents the qubit in a state of superposition, and the point on the sphere represents the
\textbf{fill this in later, think it's the probabilities, but not sure}. The polarization of a photon, or the direction of its electromagnetic field, can be used with 
horizontally polarized representing the $\ket{0}$ state, and vertically polarized representing the $\ket{1}$ state. The energy levels of an atom are used in trapped ion 
quantum computers, and the $\ket{0}$ state is represented by the ground state of the atom, while the $\ket{1}$ state is represented by the excited state of the atom.

\vspace{5mm}

Physical qubits are used to store all of the information in a quantum computer, meaning ideally they would be resistant to errors, to prevent loss of information. However, in 
reality, physical qubits are extremely susceptible to errors, and thus error correction is necessary to ensure the accuracy of the information stored in qubits. The most 
common types of errors are bit-flip and phase-flip errors, which will be discussed in more depth in section \textbf{Add reference to section} \ref{sec:simpleeccircuits}. Since physical
qubit systems are so unfathomably delicate, these errors are prone to occur quite often and are caused by a multitude of different factors. This is a major reason why error 
correction is so important; there is an abundance of noise and errors when working with these systems, which leads to information loss. The most common causes of
errors are \textbf{find common causes. One can be qubits interacting with each other, causing interference in their wave functions}. Because one of the main contributors to 
noise is qubits interfering with each other, the probability of information loss increases exponentially as the number of qubits in a system increases. Since it is inherently 
impossible to eliminate the noise in quantum computers, it is necessary to devise a system that allows correction of these errors, which is the purpose of logical qubits.



\subsubsection{Trapped Ion Qubits}
\label{sec:trappedionqubits}



\subsection{Logical Qubits and Limitations of Quantum Computers}
\label{sec:logicalqubitsbrief}
Logical qubits will be discussed in further detail in section \ref{sec:logicalqubits}, but for now it is important to understand that logical qubits are a method of representing
ideal, error-resistant qubits. Logical qubits are built using a system of multiple physical qubits that are entangled together in such a way that some of the qubits, called 
auxiliary qubits, can detect and/or correct errors in the other qubits, called data qubits. As is shown in section \ref{sec:logicalqubits}, simpler logical qubits that only 
detect/correct certain types of errors can be built using smaller amount of qubits, but more practical logical qubits require at least \textbf{number} physical qubits to detect
multiple different types of errors. The number of physical qubits required to build a logical qubit is called the overhead of the logical qubit, and is a major factor in the
practicality of a logical qubit. \textbf{Say something about how there really aren't any "practical" logical qubits yet, since they all have such high overheads, computers 
cannot contain very many qubits yet, and there are issues with gate operations on logical qubits}.













\section{Quantum Circuits}
\label{sec:quantumcircuits}



\subsection{Basic Quantum Gates}
\label{sec:basicgates}
In classical computers, logic gates are used to manipulate the states of bits. More information about classical logic gates can be found \textbf{HERE} 
Similarly, qubits and qubit systems are altered 
using quantum gates. Quantum gates are represented as matrices, and are applied to qubits by multiplying the gate matrix by 
the qubit vector. The result of this multiplication is the new state of the qubit.

\subsubsection{X Gate}
\label{sec:xgate}

The X gate is the quantum analogue of the NOT gate in classical computers. It is represented by the following matrix:

\begin{center}
	$
	\begin{bmatrix}
		0 & 1 \\
		1 & 0
	\end{bmatrix}
	$
\end{center}

Similar to classical computers, if the X gate is applied to a qubit in the $\ket{0}$ state, that qubit will then be in the $\ket{1}$ state and vice versa. This can be clearly
shown using the mathematical representation of the qubit and the gate:

\[
	\begin{bmatrix}
		0 & 1 \\
		1 & 0
	\end{bmatrix}
	\times
	\begin{bmatrix}
		1 \\
		0
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1
	\end{bmatrix}
\]
\[
	\begin{bmatrix}
		0 & 1 \\
		1 & 0
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1
	\end{bmatrix}
	=
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
\]

\textbf{Add something about how the X gate flips the qubit along the x-axis of the Bloch sphere (or whatever axis it was, I forget)}

\subsubsection{Y Gate}
\label{sec:ygate}

The Y gate is represented by the following matrix:

\[
	\begin{bmatrix}
		0 & -i \\
		i & 0
	\end{bmatrix}
\]

\textbf{Fill in information about what the Y gate does}. Applying it to the $\ket{0}$ state and the $\ket{1}$ state, we get:

\[
	\begin{bmatrix}
		0 & -i \\
		i & 0
	\end{bmatrix}
	\times
	\begin{bmatrix}
		1 \\
		0
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		i
	\end{bmatrix}
\]
\[
	\begin{bmatrix}
		0 & -i \\
		i & 0
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		-i \\
		0 \\
	\end{bmatrix}
\]

\subsubsection{Z Gate}
\label{sec:zgate}

The Z gate is represented by the following matrix:

\[
	\begin{bmatrix}
		1 & 0 \\
		0 & -1
	\end{bmatrix}
\]

\textbf{Fill in information about what the Z gate does}. Applying it to the $\ket{0}$ state and the $\ket{1}$ state, we get:

\[
	\begin{bmatrix}
		1 & 0 \\
		0 & -1
	\end{bmatrix}
	\times
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
\]
\[
	\begin{bmatrix}
		1 & 0 \\
		0 & -1
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		-1 \\
	\end{bmatrix}
\]

\subsubsection{Hadamard Gate}
\label{sec:hadamardgate}

The Hadamard gate is represented by the following matrix:

\[
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
	\end{bmatrix}
\]

The hadamard gate is used to put a qubit into a superposition of the $\ket{0}$ and $\ket{1}$ states. This is extremely useful because it is what allows us to capitalize on the
quantum mechanical properties of qubits. Applying the hadamard gate to the $\ket{0}$ state and the $\ket{1}$ state, we get:

\[
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} \\
	\end{bmatrix}
\]
\[
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} \\
		-\frac{1}{\sqrt{2}} \\
	\end{bmatrix}
\]

Notice that in each of those cases the magnitude of the resulting vector is still $1$, yet the probabilities of the qubit being in the $\ket{0}$ and $\ket{1}$ states are now
both $ \frac{1}{2}$. The hadamard gate can also be applied again to remove these superpositions and return the qubits to their original states:

\[
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
\]
\[
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
		\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		\frac{1}{\sqrt{2}} \\
		-\frac{1}{\sqrt{2}} \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
\]

\subsubsection{CNOT/CX Gate}
\label{sec:cnotgate}

The CNOT gate is another one of the most important gates in quantum computing, since facilitates the entanglement of qubits, which is a key component of quantum computing. It does
this by essentially projecting the state of one qubit onto another qubit (\textbf{double check this}). The CNOT gate is the first gate we have discussed that acts on multiple
qubits instead of just one. Therefore, we must recall the tensor product of qubits that we discussed in section \ref{sec:mathrep}. We can use the tensor product to represent 
two qubits in a system, and then apply the CNOT gate to that system. Consider the following two-qubit systems:

\[
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	\otimes
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		0 \\
		1 \\
		0 \\
	\end{bmatrix}
	=
	\ket{10}
\]
\[
	\begin{bmatrix}
		1 \\
		0 \\
	\end{bmatrix}
	\otimes
	\begin{bmatrix}
		0 \\
		1 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0 \\
	\end{bmatrix}
	=
	\ket{01}
\]

If we apply the CNOT gate to the $\ket{10}$ system, we get:

\[
	\begin{bmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 0 & 1 \\
		0 & 0 & 1 & 0 \\
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		0 \\
		1 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		0 \\
		0 \\
		1 \\
	\end{bmatrix}
\]

We end up with the $\ket{11}$ state, meaning both qubits in the system are now in the $\ket{1}$ state. This is because, as previously described, the CNOT gate projects the state
of the first qubit onto the second qubit. Since the first qubit was in the $\ket{1}$ state, the second qubit is now also in the $\ket{1}$ state. Knowing this, we can now make 
the prediction that applying the CNOT gate to the $\ket{01}$ system will result in the $\ket{00}$ system, since the first qubit is in the $\ket{0}$ state. However, this is not
the case:

\[
	\begin{bmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 0 & 1 \\
		0 & 0 & 1 & 0 \\
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0 \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0 \\
	\end{bmatrix}
\]

\textbf{explain why this is, maybe give another example with a two qubit system in superposition}

\subsubsection{CZ Gate}
\label{sec:czgate}

The CZ gate is represented by the following matrix:

\[
	\begin{bmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 1 & 0 \\
		0 & 0 & 0 & -1 \\
	\end{bmatrix}
\]

\textbf{explain what the cz gate does}



\subsection{Basic Rotation Circuit}
\label{sec:basicrotationcircuit}
\subsection{Combining Quantum Gates}
\label{sec:combininggates}
\subsection{Building Quantum Gates}
\label{sec:buildinggates}
In section \ref{sec:basicgates}, we discussed some of the most common quantum gates and their functions.
However, we omitted an explanation regarding the underlying principles governing the functions of these gates.
This absence of clarification could potentially obscure the rationale behind their compositions.
In this section, we will address this oversight, demonstrating not only how these gates function, but also why they work.
The answer, unsurprisingly, involves the fundamental concept that mathematically relates qubits to gates: matrix multiplication.



\subsubsection{Building Gates by Manipulating Basis States}
\label{sec:manipulatingbasisstates}

When building a quantum logic gate, it is customary to focus on the gate's effect on the basis states of the system.
Any $n$ qubit system has $2^{n}$ basis states, each of which can be represented as a column vector with $2^{n}$ rows.
Furthermore, each basis state is a vector with a single $1$ and $2^{n} - 1$ $0$'s.
Knowing this, consider the general case of each basis state of an $n$ qubit system passing through a gate:
\begin{align*}
		\begin{bmatrix}
			a_{11} & a_{12} & \cdots & a_{12^{n}} \\
			a_{21} & a_{22} & \cdots & a_{22^{n}} \\
			\vdots & \vdots & \ddots & \vdots \\
			a_{2^{n}1} & a_{2^{n}2} & \cdots & a_{2^{n}2^{n}}
		\end{bmatrix}
		\times
		\begin{bmatrix}
			x_{i1} \\
			x_{i2} \\
			\vdots \\
			x_{i2^{n}}
		\end{bmatrix}
		=
		\begin{bmatrix}
			X_{i1} \\
			X_{i2} \\
			\vdots \\
			X_{i2^{n}}
		\end{bmatrix}
\end{align*}
Here, $i$ represents the $i^{th}$ basis state in the system (therefore $i \in \{1, 2, ..., 2^{n}\}$). 
For example, $x_{11}, x_{12}, ..., x_{12^{n}}$ are the elements of the first basis state in the system and
$X_{11}, X_{12}, ..., X_{12^{n}}$ are the elements of the corresponding output state for the first basis state.\\\\
The system of equations for such an event can be generalized as follows:
\begin{align*}
	a_{11}x_{i1} + a_{12}x_{i2} + ... + a_{12^{n}}x_{i2^{n}} &= X_{i1} \\
	a_{21}x_{i1} + a_{22}x_{i2} + ... + a_{22^{n}}x_{i2^{n}} &= X_{i2} \\
	&\mathrel{\makebox[\widthof{=}]{\vdots}} \\
	a_{2^{n}1}x_{i1} + a_{2^{n}2}x_{i2} + ... + a_{2^{n}2^{n}}x_{i2^{n}} &= X_{i2^{n}}	
\end{align*}
% IMPORTANT REWORD THIS SECTION
Now, consider some $j \in \{1, 2, ..., 2^{n}\}$. 
% Specifically this line, it may not be clear that x_{ii} is the i^{th} row of the i^{th} basis state
It is always true that for the $i^{th}$ basis state in any $n$ qubit system, $x_{ii} = 1$ and $x_{ij} = 0$ for all $j \neq i$.
For example, the first row of the first basis state of a system (where all qubits are $\ket{0}$) is always $1$, so in that case $x_{11} = 1$ and all $x_{1j}$ where $j \neq 1$ are $0$.\\\\
Thus, if the gate were to be applied to the first basis state of the system, where $x_{11} = 1$ and $x_{1j} = 0$ when $j \neq 1$, the above system of equations can be simplified to:
\begin{align*}
	a_{11} &= X_{11} \\
	a_{21} &= X_{12} \\
	&\mathrel{\makebox[\widthof{=}]{\vdots}} \\
	a_{2^{n}1} &= X_{12^{n}}
\end{align*}
Take a moment to understand why this happens by plugging the proper values into the system of equations above.\\\\
Expanding this to the general case, if the gate were to be applied to the $i^{th}$ basis state of the system, where $x_{ii} = 1$ and $x_{ij} = 0$ when $j \neq i$, then the system of equations would be reduced to:
\begin{align*}
	a_{1i} &= X_{i1} \\
	a_{2i} &= X_{i2} \\
	&\mathrel{\makebox[\widthof{=}]{\vdots}} \\
	a_{2^{n}i} &= X_{i2^{n}}
\end{align*}
where $X_{i1}, X_{i2}, ..., X_{i2^{n}}$ represent the desired output state for the basis state with $x_{ii} = 1$ (the $i^{th}$ basis state in the system). \\\\
Notice that $a_{1i}, a_{2i}, ..., a_{2^{n}i}$ are now equivalent to the desired output state for the $i^{th}$ basis state of the system.
Also notice that these are the values that compose the $i^{th}$ column of the gate matrix.
This is a crucial observation, because it provides a heuristic for building quantum gates. \\\\
The heuristic is as follows: the $i^{th}$ column of the gate matrix is the desired output vector for the $i^{th}$ basis state of the system.\\\\
Hence, the completed gate matrix for the general example would be:
\begin{align*}
	\begin{bmatrix}
		X_{11} & X_{21} & \cdots & X_{2^{n}1} \\
		X_{12} & X_{22} & \cdots & X_{2^{n}2} \\
		\vdots & \vdots & \ddots & \vdots \\
		X_{12^{n}} & X_{22^{n}} & \cdots & X_{2^{n}2^{n}}
	\end{bmatrix}
\end{align*}
Given the many systems of equations and substitutions involved in the general derivation, it may seem convoluted or difficult to follow.
For clarity, let's try a simple example and build a quantum gate for a two qubit system. These are the basis states for such a system:
\[
	\ket{00} =
	\begin{bmatrix}
		1 \\
		0 \\
		0 \\
		0		
	\end{bmatrix}
	\ket{01} =
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0	
	\end{bmatrix}
	\ket{10} =
	\begin{bmatrix}
		0 \\
		0 \\
		1 \\
		0
	\end{bmatrix}
	\ket{11} =
	\begin{bmatrix}
		0 \\
		0 \\
		0 \\
		1
	\end{bmatrix}
\]
Suppose there exists a desired output state for each of the four basis states as follows:
\begin{align*}
	\ket{00} \rightarrow \ket{A} \\
	\ket{01} \rightarrow \ket{B} \\
	\ket{10} \rightarrow \ket{C} \\
	\ket{11} \rightarrow \ket{D}
\end{align*}
We can then create an arbitrary gate and some equations to represent these transformations:
\begin{align*}
	\begin{bmatrix}
		a_{1} & b_{1} & c_{1} & d_{1} \\
		a_{2} & b_{2} & c_{2} & d_{2} \\
		a_{3} & b_{3} & c_{3} & d_{3} \\
		a_{4} & b_{4} & c_{4} & d_{4}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		1 \\
		0 \\
		0 \\
		0
	\end{bmatrix}
	&=
	\begin{bmatrix}
		A_{1} \\
		A_{2} \\
		A_{3} \\
		A_{4}
	\end{bmatrix} \\
	\begin{bmatrix}
		a_{1} & b_{1} & c_{1} & d_{1} \\
		a_{2} & b_{2} & c_{2} & d_{2} \\
		a_{3} & b_{3} & c_{3} & d_{3} \\
		a_{4} & b_{4} & c_{4} & d_{4}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0
	\end{bmatrix}
	&=
	\begin{bmatrix}
		B_{1} \\
		B_{2} \\
		B_{3} \\
		B_{4}
	\end{bmatrix} \\
	\begin{bmatrix}
		a_{1} & b_{1} & c_{1} & d_{1} \\
		a_{2} & b_{2} & c_{2} & d_{2} \\
		a_{3} & b_{3} & c_{3} & d_{3} \\
		a_{4} & b_{4} & c_{4} & d_{4}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		0 \\
		1 \\
		0
	\end{bmatrix}
	&=
	\begin{bmatrix}
		C_{1} \\
		C_{2} \\
		C_{3} \\
		C_{4}
	\end{bmatrix} \\
	\begin{bmatrix}
		a_{1} & b_{1} & c_{1} & d_{1} \\
		a_{2} & b_{2} & c_{2} & d_{2} \\
		a_{3} & b_{3} & c_{3} & d_{3} \\
		a_{4} & b_{4} & c_{4} & d_{4}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		0 \\
		0 \\
		0 \\
		1
	\end{bmatrix}
	&=
	\begin{bmatrix}
		D_{1} \\
		D_{2} \\
		D_{3} \\
		D_{4}
	\end{bmatrix}
\end{align*}
The next step is to create systems of equations for each of these events. 
First, consider the system of equations for the gate being applied to $\ket{00}$ ($i = 1$ in the general example):
\begin{align*}
	a_{1}(1) + b_{1}(0) + c_{1}(0) + d_{1}(0) &= a_{1} = A_{1} \\
	a_{2}(1) + b_{2}(0) + c_{2}(0) + d_{2}(0) &= a_{2} = A_{2} \\
	a_{3}(1) + b_{3}(0) + c_{3}(0) + d_{3}(0) &= a_{3} = A_{3} \\
	a_{4}(1) + b_{4}(0) + c_{4}(0) + d_{4}(0) &= a_{4} = A_{4}
\end{align*}
Next, for the gate applied to $\ket{01}$ ($i = 2$):
\begin{align*}
	a_{1}(0) + b_{1}(1) + c_{1}(0) + d_{1}(0) &= b_{1} = B_{1} \\
	a_{2}(0) + b_{2}(1) + c_{2}(0) + d_{2}(0) &= b_{2} = B_{2} \\
	a_{3}(0) + b_{3}(1) + c_{3}(0) + d_{3}(0) &= b_{3} = B_{3} \\
	a_{4}(0) + b_{4}(1) + c_{4}(0) + d_{4}(0) &= b_{4} = B_{4}
\end{align*}
Then, for the gate applied to $\ket{10}$ ($i = 3$):
\begin{align*}
	a_{1}(0) + b_{1}(0) + c_{1}(1) + d_{1}(0) &= c_{1} = C_{1} \\
	a_{2}(0) + b_{2}(0) + c_{2}(1) + d_{2}(0) &= c_{2} = C_{2} \\
	a_{3}(0) + b_{3}(0) + c_{3}(1) + d_{3}(0) &= c_{3} = C_{3} \\
	a_{4}(0) + b_{4}(0) + c_{4}(1) + d_{4}(0) &= c_{4} = C_{4}
\end{align*}
Finally, for the gate applied to $\ket{11}$ ($i = 4$):
\begin{align*}
	a_{1}(0) + b_{1}(0) + c_{1}(0) + d_{1}(1) &= d_{1} = D_{1} \\
	a_{2}(0) + b_{2}(0) + c_{2}(0) + d_{2}(1) &= d_{2} = D_{2} \\
	a_{3}(0) + b_{3}(0) + c_{3}(0) + d_{3}(1) &= d_{3} = D_{3} \\
	a_{4}(0) + b_{4}(0) + c_{4}(0) + d_{4}(1) &= d_{4} = D_{4}
\end{align*}
Given the above systems of equations, the pattern relating columns of the gate matrix to the desired output vectors for the basis states becomes clear.
In this case, the constructed gate matrix for these transformations is:
\begin{align*}
	\begin{bmatrix}
		A_{1} & B_{1} & C_{1} & D_{1} \\
		A_{2} & B_{2} & C_{2} & D_{2} \\
		A_{3} & B_{3} & C_{3} & D_{3} \\
		A_{4} & B_{4} & C_{4} & D_{4}
	\end{bmatrix}
\end{align*}
% Note that another interesting pattern occurs if the desired output states are all basis states as well.
% Then each column of the gate matrix is simply the basis state that the gate should transform the corresponding basis state into.
% With this knowledge, we can create a sort of "boolean" matrix that represents the desired output states for each basis state.
% We can think of columns as input states and rows as output states, and the value at the intersection of a column and row is $1$ if the output corresponds to the input, and $0$ otherwise.
% Such a matrix would look like this for a $1$ qubit system:
% \[
% 	\text{\small Output states: }
% 	\kbordermatrix{
% 		\text{\small Input states: }& \ket{0} & \ket{1} \\
% 		\ket{0} & \ket{0} \mapsto \ket{0} & \ket{1} \mapsto \ket{0} \\
% 		\ket{1} & \ket{0} \mapsto \ket{1} & \ket{1} \mapsto \ket{1}		
% 	}
% \]
Now that we know how to build a gate for an $n$ qubit system, let's apply this knowledge to build some of the gates we have already learned.




\subsubsection{Building the X (NOT) Gate}
\label{sec:buildingxgate}
As previously discussed, gates are built by considering the desired output states of all basis states of the system when passed through the gate.
The X gate is the quantum analogue of a NOT gate, so it should negate the basis states of the system.
Furthermore, a NOT gate can only negate a single bit, so the X gate should only negate a single qubit.
Thus, the X gate can only operate on a $1$ qubit system and should have the following desired output states for each basis state:
\begin{align*}
	\ket{0} \rightarrow \ket{1} :
	\begin{bmatrix}
		1 \\
		0
	\end{bmatrix}
	\rightarrow
	\begin{bmatrix}
		0 \\
		1
	\end{bmatrix}
	\\
	\ket{1} \rightarrow \ket{0} :
	\begin{bmatrix}
		0 \\
		1
	\end{bmatrix}
	\rightarrow
	\begin{bmatrix}
		1 \\
		0
	\end{bmatrix}
\end{align*}
Recall that according to the heuristic developed in the last section, the first column of the gate should be the desired output for the first basis state
($\ket{0}$), and the second column should be the desired output for the second basis state ($\ket{1}$).
Thus, the gate matrix for the X gate should be:
\begin{align*}
	\begin{bmatrix}
		0 & 1 \\
		1 & 0
	\end{bmatrix}
\end{align*}
This is the correct X gate matrix, as shown in section \ref{sec:xgate}.
However, for the sake of completeness, let's verify again why the heuristic works as expected. \\\\
An X gate is a $1$ qubit gate, so the equation for applying the gate would be:
\begin{align*}
	\begin{bmatrix}
		a_{1} & b_{1} \\
		a_{2} & b_{2}
	\end{bmatrix}
	\times
	\begin{bmatrix}
		x_{1} \\
		x_{2}
	\end{bmatrix}
	=
	\begin{bmatrix}
		X_{1} \\
		X_{2}
	\end{bmatrix}
\end{align*}
The system of equations for this would be:
\begin{align*}
	a_{1}x_{1} + b_{1}x_{2} &= X_{1} \\
	a_{2}x_{1} + b_{2}x_{2} &= X_{2}
\end{align*}
Now, consider the situation where the input state is $\ket{0}$ and the output should be $\ket{1}$.
Our equations become:
\[
	\begin{bmatrix}
		x_{1} \\
		x_{2}
	\end{bmatrix}
	=
	\begin{bmatrix}
		1 \\
		0
	\end{bmatrix}
	,
	\begin{bmatrix}
		X_{1} \\
		X_{2}
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1
	\end{bmatrix}
\]
\begin{align*}
	a_{1}(1) + b_{1}(0) = a_{1} &= X_{1} = 0 \\
	a_{2}(1) + b_{2}(0) = a_{2} &= X_{2} = 1
\end{align*}
Clearly, the first column of the gate is the desired output for the $\ket{0}$ state, which is $\ket{1}$.
Now for the situation where the input state is $\ket{1}$ and the output should be $\ket{0}$:
\[
	\begin{bmatrix}
		x_{1} \\
		x_{2}
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 \\
		1
	\end{bmatrix}
	,
	\begin{bmatrix}
		X_{1} \\
		X_{2}
	\end{bmatrix}
	=
	\begin{bmatrix}
		1 \\
		0
	\end{bmatrix}
\]
\begin{align*}
	a_{1}(0) + b_{1}(1) = b_{1} &= X_{1} = 1 \\
	a_{2}(0) + b_{2}(1) = b_{2} &= X_{2} = 0
\end{align*}
Again, the heuristic holds true, and the second column of the gate is the desired output for the $\ket{1}$ state, which is $\ket{0}$.
We now have that $a_{1} = 0$, $a_{2} = 1$, $b_{1} = 1$, and $b_{2} = 0$. This gives us the matrix:
\[
	\begin{bmatrix}
		a_{1} & b_{1} \\
		a_{2} & b_{2}
	\end{bmatrix}
	=
	\begin{bmatrix}
		0 & 1 \\
		1 & 0
	\end{bmatrix}
\]
Thus, we have constructed the X gate (\ref{sec:xgate}).


\subsubsection{Building Other Common Quantum Gates}
\label{sec:buildingcommongates}
Now that we understand how quantum gates are constructed, we can understand why the gates we have already learned work as expected.
Consider the CNOT gate, or controlled NOT gate.
As previously discussed, the CNOT gate projects the state of the first qubit onto the second qubit.
In other words, the second qubit should be flipped if and only if the first qubit is in the $\ket{1}$ state.
It is a gate that operates on two qubits, so the gate matrix should be a $4 \times 4$ matrix.
Given the logic for how the gate should operate, the basis states should transform as follows:
\begin{align*}
	\ket{00} \rightarrow \ket{00} :
	\begin{bmatrix}
		1 \\
		0 \\
		0 \\
		0
	\end{bmatrix}
	\rightarrow
	\begin{bmatrix}
		1 \\
		0 \\
		0 \\
		0
	\end{bmatrix}
	\\
	\ket{01} \rightarrow \ket{01} :
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0
	\end{bmatrix}
	\rightarrow
	\begin{bmatrix}
		0 \\
		1 \\
		0 \\
		0
	\end{bmatrix}
	\\
	\ket{10} \rightarrow \ket{11} :
	\begin{bmatrix}
		0 \\
		0 \\
		1 \\
		0
	\end{bmatrix}
	\rightarrow
	\begin{bmatrix}
		0 \\
		0 \\
		0 \\
		1
	\end{bmatrix}
	\\
	\ket{11} \rightarrow \ket{10} :
	\begin{bmatrix}
		0 \\
		0 \\
		0 \\
		1
	\end{bmatrix}
	\rightarrow
	\begin{bmatrix}
		0 \\
		0 \\
		1 \\
		0
	\end{bmatrix}
\end{align*}
Therefore, based on the heuristic, the gate matrix should be:
\begin{align*}
	\begin{bmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 0 & 1 \\
		0 & 0 & 1 & 0
	\end{bmatrix}
\end{align*}

\subsection{Grover's Algorithm}
\label{sec:groversalgorithm}
\subsubsection{Why Grover's Algorithm Works}
\label{sec:whygroverworks}
\subsection{Circuit Calculator}
\label{sec:circuitcalculator}







\section{Logical Qubits and Error Correction}
\label{sec:errorcorrection}

\subsection{Logical Qubits}
\label{sec:logicalqubits}
\subsection{Where Logical Qubits are Used}
\label{sec:wherelqused}
\subsection{Simple Error Correction Circuits}
\label{sec:simpleeccircuits}
\subsubsection{Bit-Flip Code}
\label{sec:bitflipcode}
\subsubsection{Phase-Flip Code}
\label{sec:phaseflipcode}
\subsection{Shor's Code}
\label{sec:shorscode}
\subsection{Logical Gates}
\label{sec:logicalgates}
\subsection{Bacon-Shor Code}
\label{sec:baconshor}
\subsubsection{Ancilla Qubits}
\label{sec:ancillaqubits}
\subsubsection{Why Ancilla Qubits Do Not Disrupt the System}
\label{sec:ancilladisruption}



\end{document}


\bibliographystyle{unsrtnat}
\bibliography{references}  %%% Uncomment this line and comment out the ``thebibliography'' section below to use the external .bib file (using bibtex) .


%%% Uncomment this section and comment out the \bibliography{references} line above to use inline references.
% \begin{thebibliography}{1}

% 	\bibitem{kour2014real}
% 	George Kour and Raid Saabne.
% 	\newblock Real-time segmentation of on-line handwritten arabic script.
% 	\newblock In {\em Frontiers in Handwriting Recognition (ICFHR), 2014 14th
% 			International Conference on}, pages 417--422. IEEE, 2014.

% 	\bibitem{kour2014fast}
% 	George Kour and Raid Saabne.
% 	\newblock Fast classification of handwritten on-line arabic characters.
% 	\newblock In {\em Soft Computing and Pattern Recognition (SoCPaR), 2014 6th
% 			International Conference of}, pages 312--318. IEEE, 2014.

% 	\bibitem{hadash2018estimate}
% 	Guy Hadash, Einat Kermany, Boaz Carmeli, Ofer Lavi, George Kour, and Alon
% 	Jacovi.
% 	\newblock Estimate and replace: A novel approach to integrating deep neural
% 	networks with existing applications.
% 	\newblock {\em arXiv preprint arXiv:1804.09028}, 2018.

% \end{thebibliography}
